---
title: SpinLock
author: LHH
date: 2023-02-26 17:15 GMT+0900
categories: [C#, Server]
tags: [Rookiss 강의, C#, Server]
---

## SpinLock이란?
SpinLock은 만약 다른 스레드가 lock을 소유하고 있다면 그 lock이 반환될 때까지 계속 확인하며 기다리는 것이다.

## 💻 코드

<details>
<summary> [ Source Code (Click) ] </summary>
<div markdown="1">

```cs
class SpinLock
{
    volatile bool _locked = false;

    // Enter
    public void Acquire()
    {
        // 잠김이 풀리기를 기다린다.
        while (_locked == true)
        {
            
        }

        // 내꺼!
        _locked = true;
    }

    // Exit
    public void Release()
    {
        _locked = false;
    }
}

class Program
{
    static int _num = 0;
    static SpinLock _lock = new SpinLock();

    static void Thread_1()
    {
        for(int i=0; i<100000; i++)
        {
            _lock.Acquire();
            _num++;
            _lock.Release();
        }
    }

    static void Thread_2()
    {
        for (int i = 0; i < 100000; i++)
        {
            _lock.Acquire();
            _num--;
            _lock.Release();
        }
    }

    static void Main(string[] args)
    {
        Task t1 = new Task(Thread_1);
        Task t2 = new Task(Thread_2);

        t1.Start();
        t2.Start();

        Task.WaitAll(t1, t2);

        Console.WriteLine(_num);
    }
}
```

</div>
</details>

다음 코드와 같이 실행하게 되면 _num의 값은 0이 아니라 아에 다른값이 나오는 것을 확인할 수 있다. <br>
이러한 문제를 해결하기 위해 두가지 방법이 있다.
- `Interlocked.Exchange(ref location, value);`
- `Interlocked.CompareExChange(ref location, desired, expected);`


## Interlocked.Exchange
`Interlocked.Exchange`를 코드로 풀어보면 아래와 같은 느낌이다. <br>
```cs
public void Acquire()
{
    while (true)
    {
        int original = _locked;
        _locked = 1;
        if (original == 0)
            break;
    }
}
```
하지만 이렇게 구현을 한다면 두줄의 코드를 거쳐 실행되기 때문에 공동으로 사용되는 _locked가 다른 스레드에서 사용될 수도 있다. <br>
이 때문에 한줄로 구현해줄 필요가 있으며 구현 방법은 다음과 같다.

<br>

```cs
public void Acquire()
{
    while (true)
    {
        int original = Interlocked.Exchange(ref _locked, 1);
        if (original == 0)
            break;
    }
}
```
`Interlocked.Exchange(ref _locked, 1)`가 실행되면 _locked에 1을 넣게된다. <br>
`Interlocked.Exchange`의 반환값은 _locked에 1이 들어가기 전의 값을 반환해준다.

## Interlocked.CompareExchange
```cs
public void Acquire()
{
    while (true)
    {
        // CAS Compare-And-Swap
        // Interlocked.CompareExchange를 풀어보면 아래와 같은 느낌이다.
        // if (_locked == 0)
        //     _locked = 1;
        // 인자값을 넘겨줄 때 0, 1로 넘겨줘도 되지만 이해하기 슆게 expected, desired를 선언했다.
        int expected = 0;
        int desired = 1;
        if (Interlocked.CompareExchange(ref _locked, desired, expected) == expected)
            break;
    }
}
```
`Interlocked.CompareExChange`는 `Interlocked.Exchange`와 비슷하지만 조금 더 정교하다.<br>
사용법은 _locked의 이전값이 expected라면 _locked에 desired 값을 반환한다. <br>
리턴값은 Exchange와 똑같이 이전 값을 리턴한다.

<br>

## 💡 참고
- [Rookiss 강의: Part4 서버](https://www.inflearn.com/course/%EC%9C%A0%EB%8B%88%ED%8B%B0-mmorpg-%EA%B0%9C%EB%B0%9C-part4)
- [불곰: SpinLock](https://brownbears.tistory.com/45)
- [rito15: SpinLock](https://rito15.github.io/posts/03-cs-spinlock/)